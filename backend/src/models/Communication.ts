import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn,
  Index
} from 'typeorm'
import { User } from './User'
import { Candidate } from './Candidate'
import { Client } from './Client'
import { Job } from './Job'

@Entity('communications')
export class Communication {
  @PrimaryGeneratedColumn('uuid')
  id: string

  @Column({
    type: 'enum',
    enum: ['email', 'phone', 'sms', 'linkedin', 'in_person', 'video_call', 'note'],
  })
  @Index()
  type: string

  @Column({
    type: 'enum',
    enum: ['inbound', 'outbound'],
  })
  direction: string

  @Column({ nullable: true })
  @Index()
  subject: string

  @Column({ type: 'text' })
  content: string

  @Column({
    type: 'enum',
    enum: ['scheduled', 'sent', 'delivered', 'read', 'replied', 'failed', 'cancelled'],
    default: 'sent'
  })
  @Index()
  status: string

  @Column({ nullable: true })
  scheduledFor: Date

  @Column({ nullable: true })
  sentAt: Date

  @Column({ nullable: true })
  deliveredAt: Date

  @Column({ nullable: true })
  readAt: Date

  @Column({ nullable: true })
  repliedAt: Date

  @Column({ type: 'jsonb', nullable: true })
  recipients: {
    email?: string
    phone?: string
    name?: string
    type: 'to' | 'cc' | 'bcc'
  }[]

  @Column({ nullable: true })
  fromEmail: string

  @Column({ nullable: true })
  fromPhone: string

  @Column({ type: 'jsonb', nullable: true })
  attachments: {
    fileName: string
    fileSize: number
    mimeType: string
    documentId?: string
  }[]

  @Column({ type: 'jsonb', nullable: true })
  metadata: {
    messageId?: string
    threadId?: string
    inReplyTo?: string
    references?: string[]
    priority?: 'low' | 'normal' | 'high'
    readReceipt?: boolean
    deliveryReceipt?: boolean
    autoGenerated?: boolean
    templateId?: string
    campaignId?: string
    trackingPixel?: boolean
    clickTracking?: boolean
    unsubscribeLink?: boolean
    ipAddress?: string
    userAgent?: string
    location?: {
      city?: string
      country?: string
      timezone?: string
    }
  }

  @Column({ type: 'jsonb', nullable: true })
  tags: string[]

  @Column({ type: 'text', nullable: true })
  notes: string

  @Column({ default: false })
  isImportant: boolean

  @Column({ default: false })
  isArchived: boolean

  @Column({ nullable: true })
  followUpDate: Date

  @Column({ default: 0 })
  openCount: number

  @Column({ default: 0 })
  clickCount: number

  @Column({ nullable: true })
  lastOpenedAt: Date

  @Column({ nullable: true })
  lastClickedAt: Date

  @Column({ type: 'decimal', precision: 3, scale: 2, nullable: true })
  sentimentScore: number

  @Column({ nullable: true })
  languageDetected: string

  @Column({ type: 'jsonb', nullable: true })
  aiAnalysis: {
    intent?: 'inquiry' | 'application' | 'follow_up' | 'complaint' | 'feedback' | 'other'
    urgency?: 'low' | 'medium' | 'high'
    sentiment?: 'positive' | 'neutral' | 'negative'
    keyTopics?: string[]
    suggestedActions?: string[]
    needsResponse?: boolean
    priority?: number
  }

  @CreateDateColumn()
  @Index()
  createdAt: Date

  // Relationships
  @ManyToOne(() => User, user => user.communications)
  @JoinColumn({ name: 'createdById' })
  createdBy: User

  @Column()
  createdById: string

  @ManyToOne(() => Candidate, candidate => candidate.communications, { nullable: true })
  @JoinColumn({ name: 'candidateId' })
  candidate: Candidate

  @Column({ nullable: true })
  candidateId: string

  @ManyToOne(() => Client, client => client.communications, { nullable: true })
  @JoinColumn({ name: 'clientId' })
  client: Client

  @Column({ nullable: true })
  clientId: string

  @ManyToOne(() => Job, job => job.communications, { nullable: true })
  @JoinColumn({ name: 'jobId' })
  job: Job

  @Column({ nullable: true })
  jobId: string

  @ManyToOne(() => Communication, { nullable: true })
  @JoinColumn({ name: 'parentId' })
  parent: Communication

  @Column({ nullable: true })
  parentId: string

  // Virtual properties
  get isEmail(): boolean {
    return this.type === 'email'
  }

  get isPhone(): boolean {
    return ['phone', 'sms'].includes(this.type)
  }

  get isScheduled(): boolean {
    return this.status === 'scheduled'
  }

  get isPending(): boolean {
    return ['scheduled', 'sent'].includes(this.status)
  }

  get isDelivered(): boolean {
    return ['delivered', 'read', 'replied'].includes(this.status)
  }

  get isFailed(): boolean {
    return this.status === 'failed'
  }

  get hasAttachments(): boolean {
    return !!this.attachments && this.attachments.length > 0
  }

  get attachmentCount(): number {
    return this.attachments?.length || 0
  }

  get isOverdue(): boolean {
    if (!this.scheduledFor) return false
    return new Date() > this.scheduledFor && this.status === 'scheduled'
  }

  get needsFollowUp(): boolean {
    if (!this.followUpDate) return false
    return new Date() >= this.followUpDate
  }

  get responseTime(): number | null {
    if (!this.sentAt || !this.repliedAt) return null
    return this.repliedAt.getTime() - this.sentAt.getTime()
  }

  get responseTimeHours(): number | null {
    const responseTime = this.responseTime
    return responseTime ? Math.round(responseTime / (1000 * 60 * 60) * 10) / 10 : null
  }

  get engagementScore(): number {
    let score = 0
    
    if (this.status === 'read') score += 2
    if (this.status === 'replied') score += 5
    if (this.openCount > 1) score += this.openCount
    if (this.clickCount > 0) score += this.clickCount * 2
    
    return Math.min(score, 10)
  }

  get displaySubject(): string {
    if (this.subject) return this.subject
    
    const preview = this.content.substring(0, 50)
    return preview.length === 50 ? preview + '...' : preview
  }

  get recipientList(): string {
    if (!this.recipients) return ''
    return this.recipients
      .filter(r => r.type === 'to')
      .map(r => r.name || r.email || r.phone)
      .join(', ')
  }

  get ageInDays(): number {
    return Math.floor((new Date().getTime() - this.createdAt.getTime()) / (1000 * 60 * 60 * 24))
  }

  get priority(): 'low' | 'medium' | 'high' {
    if (this.isImportant) return 'high'
    if (this.aiAnalysis?.urgency) return this.aiAnalysis.urgency
    if (this.metadata?.priority) return this.metadata.priority
    return 'medium'
  }
}